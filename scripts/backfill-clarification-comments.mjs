#!/usr/bin/env node
/**
 * Backfill clarification comments for cached evaluations
 *
 * Reads the evaluation cache and posts clarification comments
 * for all issues that have suggestedQuestions but no comment posted yet
 */

import { promises as fs } from 'fs';
import { join } from 'path';
import { GitHubAPI } from '../dist/github/api.js';
import { getGitHubToken } from '../dist/utils/github-token.js';
import { ConfigManager } from '../dist/core/config-manager.js';
import chalk from 'chalk';

async function main() {
  const projectPath = process.argv[2] || process.cwd();
  console.log(chalk.blue('üîÑ Backfilling clarification comments\n'));
  console.log(chalk.dim(`Project: ${projectPath}\n`));

  // Load configuration
  const configManager = new ConfigManager(projectPath);
  await configManager.load();
  const config = configManager.getConfig();

  // Initialize GitHub API
  const githubToken = await getGitHubToken(config.github.token);
  const githubAPI = new GitHubAPI(githubToken, config.github.owner, config.github.repo);

  // Load evaluation cache
  const cachePath = join(projectPath, '.autonomous', 'issue-evaluations.json');
  let cache;

  try {
    const data = await fs.readFile(cachePath, 'utf-8');
    cache = JSON.parse(data);
  } catch (error) {
    console.error(chalk.red('‚ùå Could not load evaluation cache'));
    console.error(chalk.dim(`   Expected at: ${cachePath}`));
    process.exit(1);
  }

  // Find evaluations with suggested questions that need comments
  const evaluationsToPost = [];

  for (const issueNum in cache.evaluations) {
    const evaluation = cache.evaluations[issueNum];

    if (
      !evaluation.hasEnoughDetail &&
      evaluation.suggestedQuestions &&
      evaluation.suggestedQuestions.length > 0
    ) {
      evaluationsToPost.push(evaluation);
    }
  }

  console.log(chalk.blue(`Found ${evaluationsToPost.length} issue(s) with clarification questions\n`));

  if (evaluationsToPost.length === 0) {
    console.log(chalk.green('‚úì No issues need clarification comments'));
    return;
  }

  // Post comments
  let posted = 0;
  let skipped = 0;
  let errors = 0;

  for (const evaluation of evaluationsToPost) {
    try {
      // Check if we already posted a comment
      const existingComments = await githubAPI.getComments(evaluation.issueNumber);
      const hasAutonomousComment = existingComments.some((comment) =>
        comment.body.includes('## ü§ñ Autonomous Evaluation')
      );

      if (hasAutonomousComment) {
        console.log(chalk.gray(`‚äò #${evaluation.issueNumber}: Comment already exists - skipping`));
        skipped++;
        continue;
      }

      // Format the comment
      const questionsList = evaluation.suggestedQuestions
        .map((q, i) => `${i + 1}. ${q}`)
        .join('\n');

      const comment = `## ü§ñ Autonomous Evaluation

This issue needs more details before autonomous work can begin.

**AI Assessment:**
- **Complexity**: ${evaluation.classification.complexity}
- **Impact**: ${evaluation.classification.impact}
- **Clarity Score**: ${evaluation.scores.clarity}/10
- **Feasibility Score**: ${evaluation.scores.feasibility}/10

**Questions for Clarification:**

${questionsList}

**Reasoning:**
${evaluation.reasoning}

---

*Please update the issue description with these details so autonomous processing can proceed.*

<sub>Generated by [Autonomous](https://github.com/stokedconsulting/autonomous) ‚Ä¢ AI-powered issue evaluation</sub>`;

      await githubAPI.createComment(evaluation.issueNumber, comment);
      console.log(chalk.green(`‚úì #${evaluation.issueNumber}: Posted ${evaluation.suggestedQuestions.length} clarification questions`));
      posted++;

      // Rate limiting delay
      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch (error) {
      console.log(chalk.red(`‚úó #${evaluation.issueNumber}: Failed - ${error.message}`));
      errors++;
    }
  }

  // Summary
  console.log(chalk.blue('\nüìä Backfill Summary:'));
  console.log(`   ‚úì Posted: ${posted}`);
  console.log(`   ‚äò Skipped (already posted): ${skipped}`);
  console.log(`   ‚úó Errors: ${errors}`);

  if (posted > 0) {
    console.log(chalk.green('\n‚úì Backfill complete!'));
  }
}

main().catch((error) => {
  console.error(chalk.red('‚ùå Backfill failed:'), error);
  process.exit(1);
});
